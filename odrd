#!/usr/bin/env python
# vim:set encoding=utf-8 ft=python ts=8 sw=4 sts=4 et cindent:

# odrd -- OpenVPN DHCP Requestor daemon
#
# Copyright Â© 2010 Fabian Knittel <fabian.knittel@avona.com>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

import sys
import logging
import weakref
import re
import traceback
import os
import pwd
import grp
import time
import signal
import prctl
import socket
import random
from optparse import OptionParser
from ConfigParser import SafeConfigParser

import odr.ovpn as ovpn
from odr.cmdconnection import CommandConnection, CommandConnectionListener
from odr.timeoutmgr import TimeoutManager
from odr.socketloop import SocketLoop
import odr.dhcprequestor
from odr.weakmethod import WeakBoundMethod


CONFIG_FILE = '/etc/odr.conf'


class ParseUsername(object):
    USERNAME_RE = re.compile(r'^(?P<username>[^/@]+)(/(?P<resource>[^/@]+))?(@((?P<domain>[^/@]+)/)?(?P<realm>[^/@]+))?$')

    def __init__(self, default_realm):
        self._default_realm = default_realm
        self.log = logging.getLogger('parseusername')

    def parse_username(self, full_username):
        m = self.USERNAME_RE.match(full_username)
        if m is None:
            self.log.warning('username in unexpected format: "%s"' % \
                    full_username)
            return None
        realm = m.group('realm')

        if realm is None:
            if self._default_realm is None:
                self.log.warning('username contains no realm: "%s"' % \
                        full_username)
                return None
            self.log.debug('no realm specified, using default realm "%s"' % \
                    self._default_realm)
            realm = self._default_realm

        return {'username':m.group('username'),
                'resource':m.group('resource'),
                'domain':m.group('domain'),
                'realm':realm}


class OvpnClient(object):
    """Represents an OpenVPN client connected to a specific OpenVPN server
    instance.
    """

    def __init__(self, timeout_mgr, refresh_lease_clb, full_username,
                server, realm_data, leased_ip_address, rebinding_timeout):
        self._timeout_mgr = timeout_mgr
        self._refresh_lease = refresh_lease_clb
        self.full_username = full_username
        self.server = server
        self._realm_data = realm_data
        self._leased_ip_address = leased_ip_address
        self._rebinding_timeout = rebinding_timeout

        self._active = True
        self._timeout_mgr.add_timeout_object(self)
        self.log = logging.getLogger('ovpnclient')

    def __str__(self):
        return '%s on %s' % (self.full_username, self.server)

    def __repr__(self):
        return "<OvpnClient(common_name=%s, server=%s, ...)>" % (
                self.full_username, self.server)

    def set_inactive(self):
        """Disable the client.  Although any pending activities will continue,
        no new activities will be started.
        """
        self._active = False

    @property
    def timeout_time(self):
        return self._rebinding_timeout

    def handle_timeout(self):
        """Called as soon as the rebinding timeout occurs.
        """
        if not self._active:
            return

        try:
            self._refresh_lease(
                    success_handler_clb=self._handle_lease_refresh_succeeded,
                    failure_handler_clb=self._handle_lease_refresh_failed,
                    client_identifier=self.full_username,
                    device=self._realm_data.dhcp_listening_device,
                    local_ip=self._realm_data.dhcp_listening_ip,
                    local_port=self._realm_data.dhcp_local_port,
                    server_ips=self._realm_data.dhcp_server_ips,
                    client_ip=self._leased_ip_address,
                    lease_time=self._realm_data.expected_dhcp_lease_time)
        except:
            self.log.exception('Adding a new DHCP refresh request failed')
            self.server.disconnect_client(self.full_username)

    def _handle_lease_refresh_succeeded(self, res):
        if not self._active:
            return

        self.log.debug('DHCP refresh request succeeded: %s' % repr(res))
        self._leased_ip_address=res['ip-address']
        self._rebinding_timeout=res['rebinding_timeout']
        self._timeout_mgr.add_timeout_object(self)

    def _handle_lease_refresh_failed(self):
        if not self._active:
            return

        self.server.disconnect_client(self.full_username)



class OvpnClientManager(object):
    """Manages a list of all clients currently connected to all known OpenVPN
    servers.  Takes care of regularly refreshing the client's DHCP leases.

    Periodically polls the OpenVPN servers to sync the list of connected
    clients.
    """
    def __init__(self, timeout_mgr, realms_data, parse_username_clb, servers,
            refresh_lease_clb, sync_interval=60):
        """\
        @param timeout_mgr: Reference to a timeout manager.
        @param realms_data: Map of realm names to realm data structures.
        @param parse_username_clb: Call-back to parse the full_username into
            its components.
        @param servers: List of OpenVPN servers to query.
        @param refresh_lease_clb: Callback for refreshing a DHCP lease.
        @param sync_interval: Intervall in which to poll the servers.
        """
        self._timeout_mgr = timeout_mgr
        self._realms_data = realms_data
        self._parse_username = parse_username_clb
        self._servers = servers
        self._refresh_lease = refresh_lease_clb
        self._sync_interval = sync_interval

        self.log = logging.getLogger('ovpnclientmgr')
        self._clients_by_username = {}

        self._clients_by_server = {}
        for server in self._servers.values():
            self._clients_by_server[server] = {}

        self._timeout_mgr.add_rel_timeout(0, WeakBoundMethod(
                self._on_sync_clients))

    def create_client(self, **kwargs):
        client = OvpnClient(timeout_mgr=self._timeout_mgr,
                refresh_lease_clb=self._refresh_lease, **kwargs)
        self._add_client(client)
        return client

    def _add_client(self, client):
        """Add a client, based on a completed and successful DHCP request.
        """
        if client.full_username in self._clients_by_username:
            self.log.info('replacing client connection in client list with ' \
                    'freshly connected client instance: %s' % client)
            self._del_client(self._clients_by_username[client.full_username])
        else:
            self.log.debug('adding new client instance: %s' % client)

        self._clients_by_username[client.full_username] = client
        self._clients_by_server[client.server][client.full_username] = client

    def sync_clients(self):
        """Syncs the client list with the client lists of each OpenVPN server.

        Any client connected to the server but not listed by us needs to be
        added to our client list.  Those client's leases need to be refreshed
        soon, as their last refresh time is unknown to us.

        Any clients that are listed by us but no longer listed by the OpenVPN
        server are removed from our list.  They have been disconnected.
        """
        for server in self._servers.values():
            # Asynchronously retrieve the list of clients against which to sync.
            server.poll_client_list(lambda client_data_list: \
                    self._sync_clients_with(client_data_list, server))

    def _on_sync_clients(self):
        """Timeout event handler to regularly sync clients.  See sync_clients().
        """
        self.sync_clients()
        self._timeout_mgr.add_rel_timeout(self._sync_interval,
                WeakBoundMethod(self._on_sync_clients))

    def _sync_clients_with(self, client_data_list, server):
        """Called per-server as soon as the server's client data list has
        been retrieved.  Performs the actual processing as documented for
        sync_clients().
        """
        if client_data_list is None:
            self.log.error('syncing the client list with server %s failed' % \
                    server)
            return

        client_data_by_username = {}

        for client_data in client_data_list:
            self.log.debug('client_data: "%s" with "%s"' % (
                    client_data.common_name, client_data.virtual_address))
            if client_data.virtual_address is None:
                # Connection hasn't been fully established yet.  Skip it.
                continue

            client_data_by_username[client_data.common_name] = client_data

            if client_data.common_name in self._clients_by_username:
                client = self._clients_by_username[client_data.common_name]
                if client.server != server:
                    # The client has jumped servers.  Remove it from the list.
                    self.log.debug('cleaning up: client "%s" has moved ' \
                            'from server "%s" to server "%s".' % (
                            client.full_username, client.server, server))
                    self._del_client(client)

            if client_data.common_name not in self._clients_by_username:
                # New client!  Assume pessimistic last lease update time.  We're
                # probably recovering from a daemon restart.
                self._create_detected_client(client_data, server)

        for client in self._clients_by_server[server].values():
            if client.full_username not in client_data_by_username:
                # The client has been disconnected.
                self.log.debug('cleaning up: client "%s" was disconnected in ' \
                        'the mean-while.' % client.full_username)
                self._del_client(client)

    def _del_client(self, client):
        client.set_inactive()
        del self._clients_by_username[client.full_username]
        del self._clients_by_server[client.server][client.full_username]

    def _create_detected_client(self, client_data, server):
        """Create a client instance based off of client data retrieved from an
        OpenVPN server.  As we have no knowledge of the last DHCP lease refresh
        time, the client's next lease update time is set to "soon".
        """
        full_username = client_data.common_name
        self.log.debug('detected client "%s"' % full_username)
        ret = self._parse_username(full_username)
        if ret is None:
            self.log.warning('parsing detected username failed: "%s"' % \
                    full_username)
            server.disconnect_client(full_username)
            return
        realm = ret['realm']

        if realm not in self._realms_data:
            self.log.warning('unknown realm "%s" for user "%s"' % (realm,
                    full_username))
            server.disconnect_client(full_username)
            return

        # We have no idea when the last refresh occured for this client,
        # but it's unlikely to be needed immediately.  Spread out the
        # requests a bit.
        rebinding_timeout = time.time() + random.uniform(0, 10)

        client = self.create_client(server=server,
                full_username=client_data.common_name,
                realm_data=self._realms_data[realm],
                leased_ip_address=client_data.virtual_address,
                rebinding_timeout=rebinding_timeout)



class OpenVpnCmdConn(CommandConnection):
    def __init__(self, sloop, sock, realms_data, servers, add_request_clb,
            parse_username_clb, create_client_clb):
        CommandConnection.__init__(self, sloop=sloop, sock=sock)
        self._realms_data = realms_data
        self._servers = servers
        self._add_request = add_request_clb
        self._parse_username = parse_username_clb
        self._create_client = create_client_clb
        self._ret_f = None
        self._wrote_ret = False
        self._config_f = None
        self.log = logging.getLogger('ovpncmd')

    def __del__(self):
        self.log.debug('destructing OpenVpnCmdConn')
        if self._ret_f is not None:
            if not self._wrote_ret:
                self._write_ret(ovpn.CC_RET_FAILED)
            self._ret_f.close()
        if self._config_f is not None:
            self._config_f.close()
        CommandConnection.__del__(self)

    def _write_ret(self, val):
        self.log.debug('writing deferred return value %d' % val)
        ovpn.write_deferred_ret_file(self._ret_f, val)
        self._wrote_ret = True

    def _verify_lease_expectations(self, res):
        # The timeout may be reduced by a few seconds due to the time used up
        # by the DHCP hand-shake.
        DHCP_HANDSHAKE_TIME = 30

        exp_lease_timeout = time.time() + \
                self._realm_data.expected_dhcp_lease_time - DHCP_HANDSHAKE_TIME

        if res['lease_timeout'] < exp_lease_timeout:
            self.log.warn("Received IP address lease time lower than the " \
                    "expected time: %fs < %fs" % (res['lease_timeout'],
                            exp_lease_timeout))

    def _success_handler(self, res):
        self.log.debug('DHCP request succeeded: %s' % repr(res))
        self._verify_lease_expectations(res)

	self.log.debug('writing OpenVPN client configuration')
        self._config_f.seek(0)
        self._config_f.write('ifconfig-push %s %s\n' % (res['ip-address'],
                res['subnet-mask']))
        if self._realm_data.vid is not None:
            self._config_f.write('vlan-pvid %d\n' % self._realm_data.vid)
        self._config_f.write('push "ip-win32 dynamic"\n')
        self._config_f.write('push "route-gateway %s"\n' % (res['gateway']))
        self._config_f.write('push "redirect-gateway def1"\n')
        for dns_ip in res['dns']:
            self._config_f.write('push "dhcp-option DNS %s"\n' % dns_ip)
        self._config_f.write('push "dhcp-option DOMAIN %s"\n' % res['domain'])
        self._config_f.flush()
        os.fsync(self._config_f.fileno())

        self._write_ret(ovpn.CC_RET_SUCCEEDED)

        self._create_client(full_username=self._full_username,
                server=self._server, realm_data=self._realm_data,
                leased_ip_address=res['ip-address'],
                rebinding_timeout=res['rebinding_timeout'])

    def _failure_handler(self):
        self.log.debug('DHCP request failed')
        self._write_ret(ovpn.CC_RET_FAILED)

    def handle_cmd(self, cmd, params, files):
        try:
            self._full_username = params['full_username']
            ret_fidx = params['ret_file_idx']
            config_fidx = params['config_file_idx']
            server_name = params['daemon_name']
        except KeyError, e:
            self.send_cmd('FAIL')
            self.log.warning('command "%s" is missing a parameter: %s' % (cmd,
                    e.args))
            return

        try:
            ret_f = files[int(ret_fidx)]
            config_f = files[int(config_fidx)]
        except IndexError, e:
            self.send_cmd('FAIL')
            self.log.warning('file descriptor index out of range: %s' % e.args)
            return
        except ValueError, e:
            self.send_cmd('FAIL')
            self.log.warning('file descriptor index parsing failed: %s' % \
                    e.args)
            return

        ret = self._parse_username(self._full_username)
        if ret is None:
            self.send_cmd('FAIL')
            self.log.warning('parsing username failed: "%s"' % \
                    self._full_username)
            return
        realm = ret['realm']

        if realm not in self._realms_data:
            self.send_cmd('FAIL')
            self.log.error('Unknown realm %s.' % realm)
            return

        if server_name not in self._servers:
            self.send_cmd('FAIL')
            self.log.error('Unknown server %s.' % server_name)
            return

        self._realm_data = self._realms_data[realm]
        self._server = self._servers[server_name]

        self.send_cmd('OK')
        self._ret_f = ret_f
        self._config_f = config_f

        try:
            self._add_request(success_handler_clb=self._success_handler,
                    failure_handler_clb=self._failure_handler,
                    client_identifier=self._full_username,
                    device=self._realm_data.dhcp_listening_device,
                    local_ip=self._realm_data.dhcp_listening_ip,
                    local_port=self._realm_data.dhcp_local_port,
                    server_ips=self._realm_data.dhcp_server_ips,
                    lease_time=self._realm_data.expected_dhcp_lease_time)
        except:
            self.log.exception('Adding a new DHCP request failed')


def cfg_get_def(cfg, sect, opt, default=None):
    """Small helper to allow configuration options with program-defined
    defaults."""
    if cfg.has_option(sect, opt):
        return cfg.get(sect, opt)
    else:
        return default

def cfg_getint_def(cfg, sect, opt, default=None):
    """Small helper to allow configuration options with program-defined
    defaults."""
    if cfg.has_option(sect, opt):
        return cfg.getint(sect, opt)
    else:
        return default

def split_cfg_list(val):
    return [v.strip() for v in val.split(',') if (len(v.strip()) > 0)]

def cfg_iterate(cfg, section_type):
    sec_start = '%s ' % section_type
    for sect_name in [s for s in cfg.sections() if s.startswith(sec_start)]:
        elem_name = sect_name[len(sec_start):]
        yield (sect_name, elem_name)

def user_to_uid(user):
    try:
        uid = int(user)
    except ValueError:
        try:
            uid = pwd.getpwnam(user).pw_uid
        except KeyError:
            logging.critical('could not resolve user "%s", exiting', user)
            sys.exit(1)
    return uid

def group_to_gid(group):
    try:
        gid = int(group)
    except ValueError:
        try:
            gid = grp.getgrnam(group).gr_gid
        except KeyError:
            logging.critical('could not resolve group "%s", exiting', group)
            sys.exit(1)
    return gid

def users_to_uids(users):
    return [user_to_uid(user) for user in users]

def groups_to_gids(groups):
    return [group_to_gid(group) for group in groups]


def get_ip_for_iface(iface):
    """Look up an IPv4 address on the given interface.
    @param iface: Interface name
    @return: Returns the IPv4 address as string.
    """
    import netifaces
    addrs = netifaces.ifaddresses(iface)
    if netifaces.AF_INET not in addrs or \
            len(addrs[netifaces.AF_INET]) == 0 or \
            'addr' not in addrs[netifaces.AF_INET][0]:
        raise RuntimeError('Could not detect IPv4 address on interface "%s"' % \
                iface)
    return addrs[netifaces.AF_INET][0]['addr']


class RealmData(object):
    """A RealmData object contains all data relevant for a specific realm.
    The attributes are injected at configuration-load-time.
    """
    pass


def read_realms(cfg):
    """Read all realms from the configuration file into a dictionary of
    RealmData objects.
    """
    realms = {}
    for sect, realm_name in cfg_iterate(cfg, 'realm'):
        realm_data = RealmData()
        realms[realm_name] = realm_data

        realm_data.vid = cfg_getint_def(cfg, sect, 'vid')

        realm_data.dhcp_local_port = cfg_getint_def(cfg, sect,
                'dhcp_local_port', 67)

        realm_data.dhcp_listening_device = cfg_get_def(cfg, sect,
                'dhcp_listening_device')
        realm_data.dhcp_listening_ip = cfg_get_def(cfg, sect,
                'dhcp_listening_ip')

        if realm_data.dhcp_listening_device is not None and \
                realm_data.dhcp_listening_ip is None:
            # We need to determine an IPv4 address on the specified network
            # device.
            realm_data.dhcp_listening_ip = \
                    get_ip_for_iface(realm_data.dhcp_listening_device)

        realm_data.dhcp_server_ips = [socket.gethostbyname(i.strip()) for i in \
                cfg.get(sect, 'dhcp_server_ips').split(',')]

        realm_data.expected_dhcp_lease_time = \
                cfg.getint(sect, 'expected_dhcp_lease_time')
    return realms


def drop_caps(user=None, group=None, caps=[]):
    """Switches aways from UID 0 and full capabilities to a different user
    and a limited set of capabilities.  Child processes get none of the
    capabilities.
    @param user: The target user
    @param group: The target group
    @param caps: List of capabilities to retain.
    """
    if group is not None:
        # Switch to new GID.
        logging.debug('Switching to group %s' % str(group))
        gid = group_to_gid(group)
        os.setgid(gid)
        os.setgroups([gid])

    if user is not None:
        # Retain all capabilities over UID switch.
        prctl.set_keepcaps(True)

        # Switch to new UID.
        logging.debug('Switching to user %s' % str(user))
        os.setuid(user_to_uid(user))

    if len(caps) > 0:
        logging.debug('Restricting to capabilities "%s"' % ', '.join(caps))
        # Some capabilities might be permitted but not effective, so explicitly
        # set them to effective here.
        for cap in caps:
            setattr(prctl.cap_effective, cap, True)
    else:
        logging.debug('Dropping all capabilities.')
    # Drop all capabilities except those listed in "caps".
    prctl.cap_effective.limit(*caps)
    prctl.cap_permitted.limit(*caps)
    # Child processes may not use our capabilities.
    prctl.cap_inheritable.limit()


def read_servers(cfg, sloop):
    """Read all servers from the configuration file and connect to each of
    them.
    """
    servers = {}
    for sect, server_name in cfg_iterate(cfg, 'ovpn-server'):
        server = ovpn.OvpnServer(sloop, name=server_name,
                socket_fn=cfg.get(sect, 'mgmt_socket'))
        servers[server_name] = server
    return servers


def main():
    prctl.set_name('odrd')
    prctl.set_proctitle(' '.join(sys.argv))

    parser = OptionParser()
    parser.add_option("-c", "--config", dest="config_file",
            help="Configuration file", default=CONFIG_FILE)
    parser.add_option("--debug", dest="debug", action="store_true",
            help="Activate debug logging", default=False)
    parser.add_option("--keep-user", dest="keep_user", action="store_true",
            help="Do not switch to a different UID / GID; ignore capabilities",
            default=False)
    (options, args) = parser.parse_args()
    if len(args) != 0:
            parser.error("incorrect number of arguments")

    cfg = SafeConfigParser()
    cfg.read(options.config_file)

    loglevel = logging.INFO
    if options.debug:
        loglevel = logging.DEBUG
    logging.basicConfig(level=loglevel)

    if not options.keep_user:
        # Capability net_raw is needed for binding to network devices.
        # Capability net_bind_service is needed for binding to the DHCP port.
        drop_caps(user=cfg_get_def(cfg, 'daemon', 'user', None),
                group=cfg_get_def(cfg, 'daemon', 'group', None),
                caps=['net_raw', 'net_bind_service'])

    realms_data = read_realms(cfg)

    sloop = SocketLoop()

    def exit_daemon(*args):
        logging.info('exiting on signal')
        sloop.quit()

    signal.signal(signal.SIGTERM, exit_daemon)
    signal.signal(signal.SIGHUP, signal.SIG_IGN)

    timeout_mgr = TimeoutManager()
    sloop.add_idle_handler(timeout_mgr)

    requestor_mgr = odr.dhcprequestor.DhcpAddressRequestorManager()

    servers = read_servers(cfg, sloop)

    def start_dhcp_address_request(device, local_ip, **kwargs):
        requestor = requestor_mgr.get_requestor(device, local_ip)
        if requestor is None:
            return
        request = odr.dhcprequestor.DhcpAddressInitialRequest(
                timeout_mgr=weakref.proxy(timeout_mgr),
                requestor=weakref.proxy(requestor),
                local_ip=local_ip, **kwargs)
        requestor.add_request(request)

    def start_dhcp_refresh_request(device, local_ip, **kwargs):
        requestor = requestor_mgr.get_requestor(device, local_ip)
        if requestor is None:
            return
        request = odr.dhcprequestor.DhcpAddressRefreshRequest(
                timeout_mgr=weakref.proxy(timeout_mgr),
                requestor=weakref.proxy(requestor),
                local_ip=local_ip, **kwargs)
        requestor.add_request(request)

    parse_username = ParseUsername(
            default_realm=cfg_get_def(cfg, 'daemon', 'default_realm'))

    client_mgr = OvpnClientManager(timeout_mgr=timeout_mgr, servers=servers,
            refresh_lease_clb=start_dhcp_refresh_request,
            realms_data=realms_data,
            parse_username_clb=parse_username.parse_username)

    def create_vpn_cmd_conn(sloop, sock):
        return OpenVpnCmdConn(sloop, sock,
                realms_data=realms_data,
                servers=servers,
                create_client_clb=client_mgr.create_client,
                add_request_clb=start_dhcp_address_request,
                parse_username_clb=parse_username.parse_username)

    cmd_socket_uids = users_to_uids(split_cfg_list(cfg_get_def(cfg, 'daemon',
            'cmd_socket_uids', '')))
    cmd_socket_gids = groups_to_gids(split_cfg_list(cfg_get_def(cfg, 'daemon',
            'cmd_socket_gids', '')))
    def cmd_conn_auth_check(sock, pid, uid, gid):
        if uid in cmd_socket_uids:
            return True
        if gid in cmd_socket_gids:
            return True
        return False

    cmd_socket_perms = int(cfg_get_def(cfg, 'daemon', 'cmd_socket_perms',
            '0666'), 8)
    for unix_socket_fn in split_cfg_list(cfg_get_def(cfg, 'daemon',
            'cmd_sockets', '')):
        cmd_listener = CommandConnectionListener(sloop=weakref.proxy(sloop),
                socket_path=unix_socket_fn,
                cmd_conn_factory=create_vpn_cmd_conn,
                socket_perm_mode=cmd_socket_perms,
                auth_check=cmd_conn_auth_check)
        sloop.add_socket_handler(cmd_listener)

    try:
        for realm_data in realms_data.values():
            requestor = odr.dhcprequestor.DhcpAddressRequestor(
                    listen_address=realm_data.dhcp_listening_ip,
                    listen_port=realm_data.dhcp_local_port,
                    listen_device=realm_data.dhcp_listening_device)
            sloop.add_socket_handler(requestor)
            requestor_mgr.add_requestor(requestor)
    except odr.dhcprequestor.DhcpLocalAddressBindFailed, ex:
        logging.error('Could not bind to DHCP listening address %s:%d@%s' % (
                ex.args[0], ex.args[1], ex.args[2]))
        sys.exit(1)

    if not options.keep_user:
        # Special capabilities no longer necessary.
        drop_caps()

    try:
        sloop.run()
    except:
        logging.exception('Caught exception in main loop, exiting.')
        sys.exit(1)

if __name__ == '__main__':
    main()
