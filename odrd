#!/usr/bin/env python
# vim:set encoding=utf-8 ft=python ts=8 sw=4 sts=4 et cindent:

# odrd -- OpenVPN DHCP Requestor daemon
#
# Copyright Â© 2010 Fabian Knittel <fabian.knittel@avona.com>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

import sys
import logging
import weakref
import re
import traceback
import os
import grp
import signal
import prctl
from optparse import OptionParser
from ConfigParser import SafeConfigParser

import odr.ovpn as ovpn
import odr.machasher
from odr.cmdconnection import CommandConnection, CommandConnectionListener
from odr.timeoutmgr import TimeoutManager
from odr.socketloop import SocketLoop
import odr.dhcprequestor

CONFIG_FILE = '/etc/odr.conf'

class OpenVpnCmdConn(CommandConnection):
    USERNAME_RE = r'^(?P<username>[^/@]+)(/(?P<resource>[^/@]+))?@((?P<domain>[^/@]+)/)?(?P<realm>[^/@]+)$'

    def __init__(self, sloop, socket, realms_data, add_request_clb,
            full_username_to_mac_clb):
        super(OpenVpnCmdConn, self).__init__(sloop, socket)
        self._realms_data = realms_data
        self._add_request = add_request_clb
        self._full_username_to_mac = full_username_to_mac_clb
        self._ret_f = None
        self._wrote_ret = False
        self._config_f = None
        self.log = logging.getLogger('ovpncmd')

    def __del__(self):
        self.log.debug('destructing OpenVpnCmdConn')
        if self._ret_f is not None:
            if not self._wrote_ret:
                self._write_ret(ovpn.CC_RET_FAILED)
            self._ret_f.close()
        if self._config_f is not None:
            self._config_f.close()
        CommandConnection.__del__(self)

    def _write_ret(self, val):
        self.log.debug('writing deferred return value %d' % val)
        ovpn.write_deferred_ret_file(self._ret_f, val)
        self._wrote_ret = True

    def _success_handler(self, res):
        self.log.debug('DHCP request succeeded: %s' % repr(res))
        if res['lease_time'] < self._realm_data.expected_dhcp_lease_time:
            self.log.warn("Received IP address lease time lower than the " \
                    "expected time: %ds < %ds" % (res['lease_time'],
                            self._realm_data.expected_dhcp_lease_time))

	self.log.debug('writing OpenVPN client configuration')
        self._config_f.seek(0)
        self._config_f.write('ifconfig-push %s %s\n' % (res['ip-address'],
                res['subnet-mask']))
        self._config_f.write('vlan-pvid %d\n' % self._realm_data.vid)
        self._config_f.write('push "ip-win32 dynamic"\n')
        self._config_f.write('push "route-gateway %s"\n' % (res['gateway']))
        self._config_f.write('push "redirect-gateway def1"\n')
        for dns_ip in res['dns']:
            self._config_f.write('push "dhcp-option DNS %s"\n' % dns_ip)
        self._config_f.write('push "dhcp-option DOMAIN %s"\n' % res['domain'])
        self._config_f.flush()
        os.fsync(self._config_f.fileno())

        self._write_ret(ovpn.CC_RET_SUCCEEDED)

    def _failure_handler(self):
        self.log.debug('DHCP request failed')
        self._write_ret(ovpn.CC_RET_FAILED)

    def handle_cmd(self, cmd, params, files):
        try:
            self._full_username = params['full_username']
            ret_fidx = params['ret_file_idx']
            config_fidx = params['config_file_idx']
        except KeyError, e:
            self.send_cmd('FAIL')
            self.log.warning('command "%s" is missing a parameter: %s' % (cmd,
                    e.args))
            return

        try:
            ret_f = files[int(ret_fidx)]
            config_f = files[int(config_fidx)]
        except IndexError, e:
            self.send_cmd('FAIL')
            self.log.warning('file descriptor index out of range: %s' % e.args)
            return
        except ValueError, e:
            self.send_cmd('FAIL')
            self.log.warning('file descriptor index parsing failed: %s' % \
                    e.args)
            return

        m = re.match(self.USERNAME_RE, self._full_username)
        if m is None:
            self.send_cmd('FAIL')
            self.log.warning('username in unexpected format: "%s"' % \
                    self._full_username)
            return
        self._realm = m.group('realm')

        if self._realm not in self._realms_data:
            self.send_cmd('FAIL')
            logging.error('Unknown realm %s.' % self._realm)
            return
        self._realm_data = self._realms_data[self._realm]

        self.send_cmd('OK')
        self._ret_f = ret_f
        self._config_f = config_f

        self._mac_addr = self._full_username_to_mac(self._full_username)

        try:
            self._add_request(success_handler_clb=self._success_handler,
                    failure_handler_clb=self._failure_handler,
                    mac_addr=self._mac_addr,
                    device=self._realm_data.dhcp_listening_device,
                    local_ip=self._realm_data.dhcp_listening_ip,
                    local_port=self._realm_data.dhcp_local_port,
                    server_ips=self._realm_data.dhcp_server_ips)
        except:
            self.log.exception('Adding a new DHCP request failed')

class RealmData(object):
    """A RealmData object contains all data relevant for a specific realm.
    The attributes are injected at configuration-load-time.
    """
    pass

def cfg_get_def(cfg, sect, opt, default=None):
    """Small helper to allow configuration options with program-defined
    defaults."""
    if cfg.has_option(sect, opt):
        return cfg.get(sect, opt)
    else:
        return default

def cfg_getint_def(cfg, sect, opt, default=None):
    """Small helper to allow configuration options with program-defined
    defaults."""
    if cfg.has_option(sect, opt):
        return cfg.getint(sect, opt)
    else:
        return default

def read_realms(cfg):
    """Read all realms from the configuration file into a dictionary of
    RealmData objects.
    """
    realms = {}
    for sect in [s for s in cfg.sections() if s.startswith('realm ')]:
        realm_name = sect[len('realm '):]
        realm_data = RealmData()
        realms[realm_name] = realm_data

        realm_data.vid = cfg.getint(sect, 'vid')

        realm_data.dhcp_local_port = cfg_getint_def(cfg, sect,
                'dhcp_local_port', 67)

        realm_data.dhcp_listening_device = cfg_get_def(cfg, sect,
                'dhcp_listening_device')
        realm_data.dhcp_listening_ip = cfg_get_def(cfg, sect,
                'dhcp_listening_ip')

        realm_data.dhcp_server_ips = [i.strip() for i in \
                cfg.get(sect, 'dhcp_server_ips').split(',')]

        realm_data.expected_dhcp_lease_time = \
                cfg.getint(sect, 'expected_dhcp_lease_time')
    return realms

def drop_caps(user=None, group=None, caps=[]):
    """Switches aways from UID 0 and full capabilities to a different user
    and a limited set of capabilities.  Child processes get none of the
    capabilities.
    @param user: The target user
    @param group: The target group
    @param caps: List of capabilities to retain.
    """
    import pwd
    import grp

    if group is not None:
        # Switch to new GID.
        logging.debug('Switching to group %s' % group)
        gid = grp.getgrnam(group).gr_gid
        os.setgid(gid)
        os.setgroups([gid])

    if user is not None:
        # Retain all capabilities over UID switch.
        prctl.set_keepcaps(True)

        # Switch to new UID.
        logging.debug('Switching to user %s' % user)
        os.setuid(pwd.getpwnam(user).pw_uid)

    # Some capabilities might be permitted but not effective, so explicitly
    # set them to effective here.
    logging.debug('Restricting to capabilities "%s"' % ', '.join(caps))
    for cap in caps:
        setattr(prctl.cap_effective, cap, True)
    # Drop all capabilities except those listed in "caps".
    prctl.cap_effective.limit(*caps)
    prctl.cap_permitted.limit(*caps)
    # Child processes may not use our capabilities.
    prctl.cap_inheritable.limit()

def split_cfg_int_list(val):
    return [int(v.strip()) for v in val.split(',') if (len(v.strip()) > 0)]

def main():
    prctl.set_name('odrd')
    prctl.set_proctitle(' '.join(sys.argv))

    parser = OptionParser()
    parser.add_option("-c", "--config", dest="config_file",
            help="Configuration file", default=CONFIG_FILE)
    parser.add_option("--debug", dest="debug", action="store_true",
            help="Activate debug logging", default=False)
    parser.add_option("--keep-user", dest="keep_user", action="store_true",
            help="Do not switch to a different UID / GID; ignore capabilities",
            default=False)
    (options, args) = parser.parse_args()
    if len(args) != 0:
            parser.error("incorrect number of arguments")

    cfg = SafeConfigParser()
    cfg.read(options.config_file)

    loglevel = logging.INFO
    if options.debug:
        loglevel = logging.DEBUG
    logging.basicConfig(level=loglevel)

    if not options.keep_user:
        # Capability net_raw is needed for binding to network devices.
        # Capability net_bind_service is needed for binding to the DHCP port.
        drop_caps(user=cfg.get('daemon', 'user'),
                group=cfg.get('daemon', 'group'),
                caps=['net_raw', 'net_bind_service'])

    realms_data = read_realms(cfg)

    sloop = SocketLoop()

    def exit_daemon(*args):
        logging.info('exiting on signal')
        sloop.quit()

    signal.signal(signal.SIGTERM, exit_daemon)
    signal.signal(signal.SIGHUP, signal.SIG_IGN)

    timeout_mgr = TimeoutManager()
    sloop.add_idle_handler(timeout_mgr)

    def create_dhcp_address_request(**kwargs):
        return odr.dhcprequestor.DhcpAddressRequest(
                timeout_mgr=weakref.proxy(timeout_mgr), **kwargs)

    requestor_mgr = odr.dhcprequestor.DhcpAddressRequestorManager(
            request_factory=create_dhcp_address_request)

    def create_vpn_cmd_conn(sloop, sock):
        return OpenVpnCmdConn(sloop, sock,
                realms_data=realms_data,
                add_request_clb=requestor_mgr.add_request,
                full_username_to_mac_clb=odr.machasher.hash_login_to_mac)

    cmd_socket_uids = split_cfg_int_list(cfg.get('daemon',
            'cmd_socket_uids'))
    cmd_socket_gids = split_cfg_int_list(cfg.get('daemon',
            'cmd_socket_gids'))
    def cmd_conn_auth_check(sock, pid, uid, gid):
        if uid in cmd_socket_uids:
            return True
        if gid in cmd_socket_gids:
            return True
        return False

    cmd_socket_perms = int(cfg.get('daemon', 'cmd_socket_perms'), 8)
    for unix_socket_fn in [u.strip() for u in \
            cfg.get('daemon', 'cmd_sockets').split(',')]:
        cmd_listener = CommandConnectionListener(sloop=weakref.proxy(sloop),
                socket_path=unix_socket_fn,
                cmd_conn_factory=create_vpn_cmd_conn,
                socket_perm_mode=cmd_socket_perms,
                auth_check=cmd_conn_auth_check)
        sloop.add_socket_handler(cmd_listener)

    try:
        for realm_data in realms_data.values():
            requestor = odr.dhcprequestor.DhcpAddressRequestor(
                    listen_address=realm_data.dhcp_listening_ip,
                    listen_port=realm_data.dhcp_local_port,
                    listen_device=realm_data.dhcp_listening_device)
            sloop.add_socket_handler(requestor)
            requestor_mgr.add_requestor(requestor)
    except odr.dhcprequestor.DhcpLocalAddressBindFailed, ex:
        logging.error('Could not bind to DHCP listening address %s:%d@%s' % (
                ex.args[0], ex.args[1], ex.args[2]))
        sys.exit(1)

    if not options.keep_user:
        # Special capabilities no longer necessary.
        drop_caps()

    try:
        sloop.run()
    except:
        logging.exception('Caught exception in main loop, exiting.')
        sys.exit(1)

if __name__ == '__main__':
    main()
