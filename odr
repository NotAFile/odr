#!/usr/bin/env python
# vim:set encoding=utf-8 ft=python ts=8 sw=4 sts=4 et cindent:

# odr -- OpenVPN DHCP Requestor daemon
#
# Copyright Â© 2010 Fabian Knittel <fabian.knittel@avona.com>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

from __future__ import with_statement 

import sys
import logging
import weakref
import re
import traceback
import os
import grp
import signal
import prctl
from optparse import OptionParser
from ConfigParser import SafeConfigParser

import machasher
from cmdconnection import CommandConnection, CommandConnectionListener
from timeoutmgr import TimeoutManager
from socketloop import SocketLoop
import dhcprequestor

CONFIG_FILE = '/etc/odr.conf'

class OpenVpnCmdConn(CommandConnection):
    CC_RET_FAILURE = 1
    CC_RET_SUCCESS = 2
    CC_RET_DEFERRED = 3

    USERNAME_RE = r'^(?P<username>[^/@]+)(/(?P<resource>[^/@]+))?@(?P<domain>[^/@]+)(/(?P<realm>[^/@]+))?$'

    def __init__(self, sloop, socket, realms_data, add_request_clb,
            full_username_to_mac_clb):
        super(OpenVpnCmdConn, self).__init__(sloop, socket)
        self._realms_data = realms_data
        self._add_request = add_request_clb
        self._full_username_to_mac = full_username_to_mac_clb
        self._ret_fn = None
        self._wrote_ret = False
        self.log = logging.getLogger('ovpncmd')

    def __del__(self):
        if self._ret_fn is not None and not self._wrote_ret:
            self._write_ret(self.CC_RET_FAILURE)
        CommandConnection.__del__(self)

    def _write_ret(self, val):
        self.log.debug('writing deferred return value %d to "%s"' % (val,
                self._ret_fn))
        ret_fp = open(self._ret_fn, 'wb')
        ret_fp.write('%d' % val);
        ret_fp.close()
        self._wrote_ret = True

    def _success_handler(self, res):
        self.log.debug('DHCP request succeeded: %s' % repr(res))
        if res['lease_time'] < self._realm_data.expected_dhcp_lease_time:
            self.log.warn("Received IP address lease time lower than the " \
                    "expected time: %ds < %ds" % (res['lease_time'],
                            self._realm_data.expected_dhcp_lease_time))

	self.log.debug('writing OpenVPN client configuration to "%s"' %
                self._config_fn)
        conf_fp = open(self._config_fn, 'wb')
        conf_fp.write('ifconfig-push %s %s\n' % (res['ip-address'],
                res['subnet-mask']))
        conf_fp.write('vlan-pvid %d\n' % self._realm_data.vid)
        conf_fp.write('push "ip-win32 dynamic"\n')
        conf_fp.write('push "route-gateway %s"\n' % (res['gateway']))
        conf_fp.write('push "redirect-gateway def1"\n')
        for dns_ip in res['dns']:
            conf_fp.write('push "dhcp-option DNS %s"\n' % dns_ip)
        conf_fp.write('push "dhcp-option DOMAIN %s"\n' % res['domain'])
        conf_fp.close()

        self._write_ret(self.CC_RET_SUCCESS)

    def _failure_handler(self):
        self.log.debug('DHCP request failed')
        self._write_ret(self.CC_RET_FAILURE)

    def handle_cmd(self, cmd, params):
        try:
            self._full_username = params['full_username']
            self._ret_fn = params['ret_file_name']
            self._config_fn = params['config_file_name']
        except KeyError, e:
            self.send_cmd('FAIL')
            self._write_ret(self.CC_RET_FAILURE)
            self.log.warning('command "%s" is missing a parameter: %s' % (cmd,
                    e.args))
            return

        m = re.match(self.USERNAME_RE, self._full_username)
        if m is None:
            self.send_cmd('FAIL')
            self._write_ret(self.CC_RET_FAILURE)
            self.log.warning('username in unexpected format: "%s"' % \
                    self._full_username)
            return
        self._realm = m.group('realm')

        if self._realm not in self._realms_data:
            self.send_cmd('FAIL')
            logging.error('Unknown realm %s.' % self._realm)
            return
        self._realm_data = self._realms_data[self._realm]
 
        self.send_cmd('OK')

        self._mac_addr = self._full_username_to_mac(self._full_username)

        try:
            self._add_request(success_handler_clb=self._success_handler,
                    failure_handler_clb=self._failure_handler,
                    mac_addr=self._mac_addr,
                    device=self._realm_data.dhcp_listening_device,
                    local_ip=self._realm_data.dhcp_listening_ip,
                    local_port=self._realm_data.dhcp_local_port,
                    server_ips=self._realm_data.dhcp_server_ips)
        except:
            self.log.exception('Adding a new DHCP request failed')

class RealmData(object):
    pass

def read_realms(cfg):
    realms = {}
    for sect in [s for s in cfg.sections() if s.startswith('realm ')]:
        realm_name = sect[len('realm '):]
        realm_data = RealmData()
        realm_data.dhcp_local_port = cfg.getint(sect, 'dhcp_local_port')
        realm_data.vid = cfg.getint(sect, 'vid')
        realm_data.dhcp_listening_device = \
                cfg.get(sect, 'dhcp_listening_device')
        realm_data.dhcp_listening_ip = cfg.get(sect, 'dhcp_listening_ip')
        realm_data.dhcp_server_ips = [i.strip() for i in \
                cfg.get(sect, 'dhcp_server_ips').split(',')]
        realm_data.expected_dhcp_lease_time = \
                cfg.getint(sect, 'expected_dhcp_lease_time')
        realms[realm_name] = realm_data
    return realms

def drop_caps(user=None, group=None, caps=[]):
    """Switches aways from UID 0 and full capabilities to a different user
    and a limited set of capabilities.  Child processes get none of the
    capabilities.
    @param user: The target user
    @param group: The target group
    @param caps: List of capabilities to retain.
    """
    import pwd
    import grp

    if group is not None:
        # Switch to new GID.
        os.setgid(grp.getgrnam(group).gr_gid)

    if user is not None:
        # Retain all capabilities over UID switch.
        prctl.set_keepcaps(True)

        # Switch to new UID.
        os.setuid(pwd.getpwnam(user).pw_uid)

    # Some capabilities might be permitted but not effective, so explicitly
    # set them to effective here.
    for cap in caps:
        setattr(prctl.cap_effective, cap, True)
    # Drop all capabilities except those listed in "caps".
    prctl.cap_effective.limit(*caps)
    prctl.cap_permitted.limit(*caps)
    # Child processes may not use our capabilities.
    prctl.cap_inheritable.limit()

def main():
    prctl.set_name('odr')
    prctl.set_proctitle(' '.join(sys.argv))

    parser = OptionParser()
    parser.add_option("-c", "--config", dest="config_file",
            help="Configuration file", default=CONFIG_FILE)
    parser.add_option("--debug", dest="debug", action="store_true",
            help="Activate debug logging", default=False)
    (options, args) = parser.parse_args()
    if len(args) != 0:
            parser.error("incorrect number of arguments")

    cfg = SafeConfigParser()
    cfg.read(options.config_file)

    loglevel = logging.INFO
    if options.debug:
        loglevel = logging.DEBUG
    logging.basicConfig(level=loglevel)

    logging.debug('Switching to user %s and group %s' % (
                cfg.get('daemon', 'user'), cfg.get('daemon', 'group')))
    # Capability net_raw is needed for binding to network devices.
    # Capability net_bind_service is needed for binding to the DHCP port.
    drop_caps(user=cfg.get('daemon', 'user'), group=cfg.get('daemon', 'group'),
            caps=['net_raw', 'net_bind_service'])

    realms_data = read_realms(cfg)

    sloop = SocketLoop()

    def exit_daemon(*args):
        logging.info('exiting on signal')
        sloop.quit()

    signal.signal(signal.SIGTERM, exit_daemon)
    signal.signal(signal.SIGHUP, signal.SIG_IGN)

    timeout_mgr = TimeoutManager()
    sloop.add_idle_handler(timeout_mgr)

    def create_dhcp_address_request(**kwargs):
        return dhcprequestor.DhcpAddressRequest(
                timeout_mgr=weakref.proxy(timeout_mgr), **kwargs)

    requestor_mgr = dhcprequestor.DhcpAddressRequestorManager(
            request_factory=create_dhcp_address_request)

    def create_vpn_cmd_conn(sloop, socket):
        return OpenVpnCmdConn(sloop, socket,
                realms_data=realms_data,
                add_request_clb=requestor_mgr.add_request,
                full_username_to_mac_clb=machasher.hash_login_to_mac)

    cmd_socket_perms = int(cfg.get('daemon', 'cmd_socket_perms'), 8)
    for unix_socket_fn in [u.strip() for u in \
            cfg.get('daemon', 'cmd_sockets').split(',')]:
        cmd_listener = CommandConnectionListener(sloop=weakref.proxy(sloop),
                socket_path=unix_socket_fn,
                cmd_conn_factory=create_vpn_cmd_conn,
                socket_perm_mode=cmd_socket_perms)
        sloop.add_socket_handler(cmd_listener)

    try:
        for realm_data in realms_data.values():
            requestor = dhcprequestor.DhcpAddressRequestor(
                    listen_address=realm_data.dhcp_listening_ip,
                    listen_port=realm_data.dhcp_local_port,
                    listen_device=realm_data.dhcp_listening_device)
            sloop.add_socket_handler(requestor)
            requestor_mgr.add_requestor(requestor)
    except dhcprequestor.DhcpLocalAddressBindFailed, ex:
        logging.error('Could not bind to DHCP listening address %s:%d@%s' % (
                ex.args[0], ex.args[1], ex.args[2]))
        sys.exit(1)

    # Special capabilities no longer necessary.
    drop_caps()

    try:
        sloop.run()
    except:
        logging.exception('Caught exception in main loop, exiting.')
        sys.exit(1)

if __name__ == '__main__':
    main()
