#!/usr/bin/python
# vim:set encoding=utf-8 ft=python ts=8 sw=4 sts=4 et cindent:

# ovpn-dhcp-requestord
#
# Copyright (C) 2010 Fabian Knittel <fabian.knittel@avona.com>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

from __future__ import with_statement 

import sys
sys.path.append('/opt/pydhcplib')
import logging
import logging.config
import weakref
import re
import traceback
import os
import grp
import daemon
import lockfile
import signal
from optparse import OptionParser
from ConfigParser import SafeConfigParser

import machasher
from cmdconnection import CommandConnection, CommandConnectionListener
from timeoutmgr import TimeoutManager
from socketloop import SocketLoop
from dhcprequestor import DhcpAddressRequest, DhcpAddressRequestor, \
        DhcpAddressRequestorManager

CONFIG_FILE = '/etc/ovpn-dhcp-requestord.conf'

class OpenVpnCmdConn(CommandConnection):
    CC_RET_FAILURE = 1
    CC_RET_SUCCESS = 2
    CC_RET_DEFERRED = 3

    USERNAME_RE = r'^(?P<username>[^/@]+)(/(?P<resource>[^/@]+))?@(?P<domain>[^/@]+)(/(?P<realm>[^/@]+))?$'

    def __init__(self, sloop, socket, request_realm_data_clb, add_request_clb,
            full_username_to_mac_clb):
        super(OpenVpnCmdConn, self).__init__(sloop, socket)
        self._request_realm_data = request_realm_data_clb
        self._add_request = add_request_clb
        self._full_username_to_mac = full_username_to_mac_clb
        self._ret_fn = None
        self._wrote_ret = False
        self.log = logging.getLogger('ovpncmd')

    def __del__(self):
        if self._ret_fn is not None and not self._wrote_ret:
            self._write_ret(self.CC_RET_FAILURE)
        CommandConnection.__del__(self)

    def _write_ret(self, val):
        self.log.debug('writing deferred return value %d to "%s"' % (val,
                self._ret_fn))
        ret_fp = open(self._ret_fn, 'wb')
        ret_fp.write('%d' % val);
        ret_fp.close()
        self._wrote_ret = True

    def _success_handler(self, res):
        self.log.debug('DHCP request succeeded: %s' % repr(res))
	self.log.debug('writing OpenVPN client configuration to "%s"' %
                self._config_fn)
        conf_fp = open(self._config_fn, 'wb')
        conf_fp.write('ifconfig-push %s %s\n' % (res['ip-address'],
                res['subnet-mask']))
        conf_fp.write('vlan-pvid %d\n' % self._realm_data.vid)
        conf_fp.write('push "ip-win32 dynamic"\n')
        conf_fp.write('push "route-gateway %s"\n' % (res['gateway']))
        conf_fp.write('push "redirect-gateway def1"\n')
        for dns_ip in res['dns']:
            conf_fp.write('push "dhcp-option DNS %s"\n' % dns_ip)
        conf_fp.write('push "dhcp-option DOMAIN %s"\n' % res['domain'])
        conf_fp.close()

        self._write_ret(self.CC_RET_SUCCESS)

    def _failure_handler(self):
        self.log.debug('DHCP request failed')
        self._write_ret(self.CC_RET_FAILURE)

    def handle_command(self, cmd):
        self.log.debug('handling command "%s"' % cmd)
        try:
            params = {}
            for p in cmd.split(' '):
                k, v = p.split('=')
                params[k] = v
        except:
            self.log.warning('failed to parse command "%s"')
            return
        try:
            self._full_username = params['full_username']
            self._ret_fn = params['ret_file_name']
            self._config_fn = params['config_file_name']
        except KeyError, e:
            self.send_cmd('FAIL')
            self._write_ret(self.CC_RET_FAILURE)
            self.log.warning('command "%s" is missing a parameter: %s' % (cmd,
                    e.args))
            return

        m = re.match(self.USERNAME_RE, self._full_username)
        if m is None:
            self.send_cmd('FAIL')
            self._write_ret(self.CC_RET_FAILURE)
            self.log.warning('username in unexpected format: "%s"' % \
                    self._full_username)
            return
        self._realm = m.group('realm')
        self._realm_data = self._request_realm_data(realm=self._realm)
        self.send_cmd('OK')

        self._mac_addr = self._full_username_to_mac(self._full_username)

        try:
            self._add_request(success_handler_clb=self._success_handler,
                    failure_handler_clb=self._failure_handler,
                    mac_addr=self._mac_addr,
                    local_ip=self._realm_data.dhcp_listening_ip,
                    local_port=self._realm_data.dhcp_local_port,
                    server_ips=self._realm_data.dhcp_server_ips)
        except:
            self.log.exception('Adding a new DHCP request failed')

class RealmData(object):
    pass

def main():
    parser = OptionParser()
    parser.add_option("-c", "--config", dest="config_file",
            help="Configuration file", default=CONFIG_FILE)
    parser.add_option("--debug", dest="debug", action="store_true",
            help="Activate debug logging", default=False)
    parser.add_option("--foreground", dest="foreground", action="store_true",
            help="Do not detach to background", default=False)
    (options, args) = parser.parse_args()
    if len(args) != 0:
            parser.error("incorrect number of arguments")

    cfg = SafeConfigParser()
    cfg.read(options.config_file)

    logging.config.fileConfig(options.config_file)
    log = logging.getLogger('ovpndhcprequestord')
    if options.debug:
        logging.getLogger().setLevel(logging.DEBUG)

    context = daemon.DaemonContext(
        working_directory=cfg.get('daemon', 'working_dir'),
        umask=002,
        pidfile=lockfile.FileLock(cfg.get('daemon', 'pid_file')),
    )

    sloop = SocketLoop()

    def exit_daemon():
        logging.notice('exiting on signal')
        sloop.quit

    context.signal_map = {
        signal.SIGTERM:exit_daemon,
    }

    timeout_mgr = TimeoutManager()
    sloop.add_idle_handler(timeout_mgr)

    def create_dhcp_address_request(**kwargs):
        return DhcpAddressRequest(
                timeout_mgr=weakref.proxy(timeout_mgr), **kwargs)

    requestor_mgr = DhcpAddressRequestorManager(
            request_factory=create_dhcp_address_request)

    def get_realm_data(realm):
        sect = 'realm %s' % realm
        if cfg.has_section(sect):
            realm_data = RealmData()
            realm_data.dhcp_local_port = cfg.getint(sect, 'dhcp_local_port')
            realm_data.vid = cfg.getint(sect, 'vid')
            realm_data.dhcp_listening_ip = cfg.get(sect, 'dhcp_listening_ip')
            realm_data.dhcp_server_ips = [i.strip() for i in \
                    cfg.get(sect, 'dhcp_server_ips').split(',')]
            return realm_data
        else:
            logger.error('Unknown realm %s.' % realm)
            return None

    def create_vpn_cmd_conn(sloop, socket):
        return OpenVpnCmdConn(sloop, socket,
                request_realm_data_clb=get_realm_data,
                add_request_clb=requestor_mgr.add_request,
                full_username_to_mac_clb=machasher.hash_login_to_mac)

    cmd_socket_perms = int(cfg.get('daemon', 'cmd_socket_perms'), 8)
    for unix_socket_fn in [u.strip() for u in \
            cfg.get('daemon', 'cmd_sockets').split(',')]:
        cmd_listener = CommandConnectionListener(sloop=weakref.proxy(sloop),
                socket_path=unix_socket_fn,
                cmd_conn_factory=create_vpn_cmd_conn,
                socket_perm_mode=cmd_socket_perms)
        sloop.add_socket_handler(cmd_listener)

    for realm_section in [s for s in cfg.sections() if s.startswith('realm ')]:
        requestor = DhcpAddressRequestor(
                local_ip=cfg.get(realm_section, 'dhcp_listening_ip'),
                local_port=cfg.getint(realm_section, 'dhcp_local_port'))
        sloop.add_socket_handler(requestor)
        requestor_mgr.add_requestor(requestor)

    context.files_preserve = sloop.sockets
    # XXX: Using protected attribute.
    for handler in logging._handlerList:
        # XXX: There's no proper interface for the open sockets/fds.
        if hasattr(handler, 'socket'):
            context.files_preserve.append(handler.socket)
        elif hasattr(handler, 'sock'):
            context.files_preserve.append(handler.sock)
        elif hasattr(handler, 'stream'):
            context.files_preserve.append(handler.stream)

    if not options.foreground:
        with context:
             sloop.run()
    else:
        sloop.run()

if __name__ == '__main__':
    main()
