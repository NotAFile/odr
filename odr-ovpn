#!/usr/bin/env python
# vim:set encoding=utf-8 ft=python ts=8 sw=4 sts=4 et cindent:

# ovpn-client-connect
#
# Copyright Â© 2010 Fabian Knittel <fabian.knittel@avona.com>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

import os
import sys
import socket
import odr.ovpn as ovpn
import odr.cmdconnection as cmdconnection
import fdsend

SCRIPT_NAME = 'odr-ovpn'
CMD_SOCKET = '/var/run/odr/cmd.sock'

class flushedstream(object):
    def __init__(self, f):
        self.f = f
    def write(self, x):
        self.f.write(x)
        self.f.flush()
sys.stdout = flushedstream(sys.stdout)
sys.stderr = flushedstream(sys.stderr)


#
# Gather configuration
#

cfg_f = open(os.environ['client_connect_config_file'], 'wb')
ret_f = open(os.environ['client_connect_deferred_file'], 'wb')
full_username = os.environ['username']

# We need to identify the OpenVPN server instance calling us.  We either
# look at an environment variable or try to deduce the name from the way we
# were called.
daemon_name = None
if 'daemon_name' in os.environ:
    daemon_name = os.environ['daemon_name']
else:
    b = os.path.basename(sys.argv[0])
    if b.startswith('%s_' % SCRIPT_NAME):
        daemon_name = b[len(SCRIPT_NAME) + 1:]
    del b


#
# Build and submit command
#

params = {'full_username':full_username,
        'ret_file_idx':'0',
        'config_file_idx':'1'}
if daemon_name is not None:
    params['daemon_name'] = daemon_name

s = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
s.connect(CMD_SOCKET)

ovpn.write_deferred_ret_file(ret_f, ovpn.CC_RET_DEFERRED)
try:
    fdsend.sendfds(s, cmdconnection.pack_cmd('request', params),
            fds=[ret_f, cfg_f])

    ret, _ = fdsend.recvfds(s, 1024, numfds=0)
    print 'Received: %s' % ret
    if ret != 'OK':
        raise RuntimeError('starting dhcp request failed')
except:
    ovpn.write_deferred_ret_file(ret_f, ovpn.CC_RET_FAILED)
    raise
